# Имеем входные данные в виде списка произвольной степени вложенности
# с различными тимпами элементов

data_structure = [
  [1, 2, 3],
  {'a': 4, 'b': 5},
  (6, {'cube': 7, 'drum': 8}),
  "Hello",
  ((), [{(2, 'Urban', ('Urban2', 35))}])
]

# Необходимо написать функцию calculate_structure_sum(data_structure),
# которая посчитает сумму всех чисел и длинну всех строк.
# Функция выдирающая вложенные списки

def get_lists(lst):
    # Результирующий список пока пуст
    result = []
    for elem in lst:
        # Условия входа в рекурсию
        if isinstance(elem, list):
         result.extend(get_lists(elem))
        # Выход из рекурсии
        else:
          result.append(elem)
    # Возвращаем результат рвботы функции
    return result

#Функция выдирающая вложенные словари

def get_dict(dict_, *val):
    # Обработаем вложенный словарь
    result = []
    # Тут я пытался организовать рекурсивный вызов
    if isinstance(dict_, dict):
        # Организуем цикл получения пар ключ - значение
        for key, value in dict_.items():
           # Поученные списки пар ключ-значения добавим в результирующий список
           result += [key, value]
    else:
        result.append(dict_)
    # Вернем результат работы функции
    return result

# Функция прербразующая входные данные в "плоский" список
# и подсчитывающая сууму чисел и длинну строк

def calculate_structure_sum(data_):
  # Объявим переменные
  summ = 0                    # Итогову сумму выставляем в 0
  flat_list = []              # Здесь будем формировать "плоский список"

# Органицуем цикл обрабоки вложенных элементов в зависимости от типа данных
  for elem in data_:
    # Проверка элемента на строковый тип
    if isinstance(elem, str):
      # Элементы строкового типа поместим в "плоский список"
      flat_list.append(elem)
    # Проверка элемента на списочный тип
    if isinstance(elem, list):
      # Элементы списочного типа отправляем в функцию обработки списков
      # Возращаемое значение помещаем в "плоский список"
      flat_list.extend(get_lists(elem))
    # Проыерка элемента типа кортеж
    if isinstance(elem, tuple):
      # Преобразуем элемент в список и добавим его в "плоский список"
      flat_list.extend(list(elem))
    # Проверка элемента словарного типа
    if isinstance(elem, dict):
      # Элементы словарного типа отправляем в функцию обработки словарей
      # Возращаемое значение помещаем в "плоский список"
      flat_list.extend(get_dict(elem))

# Теперь обработаем хвост списка
  for i in flat_list:
    # Обработаем вложенный словарь
    if isinstance(i, dict):
      flat_list.remove(i)
      flat_list.extend(get_dict(i))
    # Обработаем вложенный список
    if isinstance(i, list):
      flat_list.extend(i)
      flat_list.remove(i)
  # Обработаем вложенное множество
  set_ = flat_list.pop()
  flat_list.extend(*set_)
  # Обработаем последний вложенный кортеж
  tuple_ = flat_list.pop()
  flat_list += tuple_

# Полученный "плоский список" содержит как числовый так и строковые значения
# Организуем цикл обработки по длинне списка
  for k in range(len(flat_list)):
      # Если элемент число плюсуем в итоговую сумму
      if isinstance(flat_list[k], int):
        summ += flat_list[k]
      # В противном случае это строка плюсуем длинну строки
      else:
        summ += len(flat_list[k])
  # Выводим результат
  print(f'Итоговая сумма всех чисел списка и длин строк : {summ}')

#Вызов функции

calculate_structure_sum(data_structure)

# Как видим результат соответствует ожидаемому.
# Но результатом я не доволен. Это совсем не универсальный метод.
# Это решение применимо именно к этому списку.
# Мне кажется что имеет смысл начинать обработку с элемента списка
# который имеет наибольшую степень вложенности.
# Но еще более правильным считаю применить рекурсивный метод
# не к элементам списка а к самой функции **calculate_structure_sum**.
# Был бы крайне признателен вам за подсказки как это сделать